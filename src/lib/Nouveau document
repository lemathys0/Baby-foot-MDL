// üìÅ src/lib/firebaseCache.ts
// ============================
// Syst√®me de cache pour optimiser les performances Firebase

import { ref, get, onValue, off } from "firebase/database";
import { database } from "./firebase";

// Types pour le cache
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  expiresAt: number;
}

interface CacheConfig {
  ttl: number; // Time to live en millisecondes
  maxSize: number; // Nombre maximum d'entr√©es
}

// Configuration par d√©faut
const DEFAULT_CACHE_CONFIG: CacheConfig = {
  ttl: 5 * 60 * 1000, // 5 minutes
  maxSize: 100,
};

// ============================
// üóÑÔ∏è CACHE MANAGER
// ============================
class FirebaseCacheManager {
  private cache: Map<string, CacheEntry<any>>;
  private config: CacheConfig;
  private listeners: Map<string, () => void>;

  constructor(config: Partial<CacheConfig> = {}) {
    this.cache = new Map();
    this.config = { ...DEFAULT_CACHE_CONFIG, ...config };
    this.listeners = new Map();
  }

  /**
   * R√©cup√®re des donn√©es avec cache
   */
  async get<T>(key: string, fetcher: () => Promise<T>, ttl?: number): Promise<T> {
    const cached = this.cache.get(key);
    const now = Date.now();

    // V√©rifier si le cache est valide
    if (cached && cached.expiresAt > now) {
      console.log(`[Cache HIT] ${key}`);
      return cached.data as T;
    }

    console.log(`[Cache MISS] ${key}`);

    // R√©cup√©rer les nouvelles donn√©es
    const data = await fetcher();

    // Mettre en cache
    this.set(key, data, ttl);

    return data;
  }

  /**
   * Stocke des donn√©es dans le cache
   */
  set<T>(key: string, data: T, ttl?: number): void {
    const now = Date.now();
    const effectiveTtl = ttl || this.config.ttl;

    // Nettoyer le cache si trop plein
    if (this.cache.size >= this.config.maxSize) {
      this.cleanup();
    }

    this.cache.set(key, {
      data,
      timestamp: now,
      expiresAt: now + effectiveTtl,
    });
  }

  /**
   * Invalide une entr√©e du cache
   */
  invalidate(key: string): void {
    this.cache.delete(key);
    console.log(`[Cache INVALIDATE] ${key}`);
  }

  /**
   * Invalide plusieurs entr√©es par pr√©fixe
   */
  invalidatePrefix(prefix: string): void {
    for (const key of this.cache.keys()) {
      if (key.startsWith(prefix)) {
        this.cache.delete(key);
      }
    }
    console.log(`[Cache INVALIDATE PREFIX] ${prefix}*`);
  }

  /**
   * Nettoie les entr√©es expir√©es
   */
  cleanup(): void {
    const now = Date.now();
    let cleaned = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.expiresAt <= now) {
        this.cache.delete(key);
        cleaned++;
      }
    }

    // Si pas assez de nettoyage, supprimer les plus anciennes
    if (this.cache.size >= this.config.maxSize) {
      const entries = Array.from(this.cache.entries());
      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
      
      const toRemove = Math.ceil(this.config.maxSize * 0.2); // Supprimer 20%
      for (let i = 0; i < toRemove; i++) {
        this.cache.delete(entries[i][0]);
        cleaned++;
      }
    }

    if (cleaned > 0) {
      console.log(`[Cache CLEANUP] ${cleaned} entr√©es supprim√©es`);
    }
  }

  /**
   * Vide tout le cache
   */
  clear(): void {
    this.cache.clear();
    console.log("[Cache CLEAR] Cache vid√©");
  }

  /**
   * Abonne √† des changements en temps r√©el avec cache
   */
  subscribe<T>(
    key: string,
    path: string,
    callback: (data: T) => void,
    ttl?: number
  ): () => void {
    // Charger depuis le cache si disponible
    const cached = this.cache.get(key);
    if (cached && cached.expiresAt > Date.now()) {
      callback(cached.data);
    }

    // S'abonner aux changements
    const dbRef = ref(database, path);
    const unsubscribe = onValue(dbRef, (snapshot) => {
      const data = snapshot.val();
      
      // Mettre √† jour le cache
      this.set(key, data, ttl);
      
      // Appeler le callback
      callback(data);
    });

    // Stocker le listener pour le nettoyage
    this.listeners.set(key, unsubscribe);

    // Retourner la fonction de d√©sabonnement
    return () => {
      unsubscribe();
      this.listeners.delete(key);
    };
  }

  /**
   * Se d√©sabonne de tous les listeners
   */
  unsubscribeAll(): void {
    for (const unsubscribe of this.listeners.values()) {
      unsubscribe();
    }
    this.listeners.clear();
    console.log("[Cache] Tous les listeners d√©sabonn√©s");
  }
}

// Instance globale du cache
export const firebaseCache = new FirebaseCacheManager({
  ttl: 3 * 60 * 1000, // 3 minutes
  maxSize: 50,
});

// ============================
// üöÄ FONCTIONS OPTIMIS√âES
// ============================

/**
 * R√©cup√®re les joueurs du leaderboard avec cache
 */
export async function getCachedLeaderboard() {
  return firebaseCache.get(
    "leaderboard",
    async () => {
      const usersRef = ref(database, "users");
      const snapshot = await get(usersRef);
      
      if (!snapshot.exists()) return [];
      
      const players: any[] = [];
      snapshot.forEach((child) => {
        players.push({
          id: child.key!,
          ...child.val(),
        });
      });

      return players.sort((a, b) => b.eloRating - a.eloRating);
    },
    2 * 60 * 1000 // 2 minutes
  );
}

/**
 * R√©cup√®re les matchs r√©cents avec cache
 */
export async function getCachedRecentMatches(limit: number = 10) {
  return firebaseCache.get(
    `matches:recent:${limit}`,
    async () => {
      const matchesRef = ref(database, "matches");
      const snapshot = await get(matchesRef);
      
      if (!snapshot.exists()) return [];
      
      const matches: any[] = [];
      snapshot.forEach((child) => {
        matches.push({
          id: child.key!,
          ...child.val(),
        });
      });

      return matches
        .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0))
        .slice(0, limit);
    },
    1 * 60 * 1000 // 1 minute
  );
}

/**
 * R√©cup√®re les cartes d'un utilisateur avec cache
 */
export async function getCachedUserCards(uid: string) {
  return firebaseCache.get(
    `user:cards:${uid}`,
    async () => {
      const cardsRef = ref(database, `users/${uid}/cards`);
      const snapshot = await get(cardsRef);
      
      if (!snapshot.exists()) return {};
      
      return snapshot.val() || {};
    },
    5 * 60 * 1000 // 5 minutes
  );
}

/**
 * R√©cup√®re le profil d'un utilisateur avec cache
 */
export async function getCachedUserProfile(uid: string) {
  return firebaseCache.get(
    `user:profile:${uid}`,
    async () => {
      const userRef = ref(database, `users/${uid}`);
      const snapshot = await get(userRef);
      
      if (!snapshot.exists()) return null;
      
      return snapshot.val();
    },
    3 * 60 * 1000 // 3 minutes
  );
}

/**
 * S'abonne au leaderboard avec cache
 */
export function subscribeToCachedLeaderboard(callback: (players: any[]) => void) {
  return firebaseCache.subscribe(
    "leaderboard:live",
    "users",
    (data) => {
      if (!data) {
        callback([]);
        return;
      }

      const players = Object.entries(data).map(([id, userData]) => ({
        id,
        ...(userData as any),
      }));

      callback(players.sort((a, b) => b.eloRating - a.eloRating));
    },
    2 * 60 * 1000
  );
}

// ============================
// üßπ NETTOYAGE AUTOMATIQUE
// ============================

// Nettoyer le cache toutes les 5 minutes
setInterval(() => {
  firebaseCache.cleanup();
}, 5 * 60 * 1000);

// Nettoyer avant de quitter la page
if (typeof window !== "undefined") {
  window.addEventListener("beforeunload", () => {
    firebaseCache.unsubscribeAll();
  });
}

export default firebaseCache;
